use std::{fs, collections::HashMap};

fn evaluate<'a>(p: &Vec<(&str, usize)>, workflow: &'a Vec<&str>) -> &'a str {
    for r in workflow {
        if r.contains(":") {
            let (cond, dest) = r.split_once(":").unwrap();
            let (prop, rel, v) = if cond.contains(">") {
                let r = cond.split_once(">").unwrap();
                (r.0, '>', r.1.parse::<usize>().unwrap())
            } else {
                let r = cond.split_once("<").unwrap();
                (r.0, '<', r.1.parse::<usize>().unwrap())
            };

            let actual_prop = p.iter().find(|i| i.0 == prop).unwrap();
            if rel == '>' {
                if actual_prop.1 > v {
                    return dest;
                }
            } else {
                if actual_prop.1 < v {
                    return dest;
                }
            }
        } else {
            return r
        }
    }
    todo!()
}

fn main() {
    let input = fs::read_to_string("input.txt").expect("Could not read file");
    let (rules, parts) = input.split_once("\n\n").unwrap();
    let rules = rules.lines()
        .map(|line| line[0..line.len() - 1].split_once("{").unwrap())
        .map(|(name, conditions)| (name, conditions.split(",").collect::<Vec<_>>()))
        .collect::<Vec<_>>();

    let mut workflows = HashMap::new();
    for r in rules {
        workflows.insert(r.0, r.1);
    }

    let parts = parts.lines()
        .map(|l| l[1..l.len() - 1].split(",").collect::<Vec<_>>())
        .map(|p| p.into_iter().map(|c| {
            let r = c.split_once("=").unwrap();
            (r.0, r.1.parse::<usize>().unwrap())
        }).collect::<Vec<_>>())
        .collect::<Vec<_>>();

    println!("{workflows:?}");
    println!("{parts:?}");

    let mut sum = 0;
    for p in parts {
        let mut current_workflow = "in";
        loop {
            current_workflow = evaluate(&p, workflows.get(current_workflow).unwrap());
            println!("{current_workflow}");
            if current_workflow == "A" {
                sum += p.iter().map(|v| v.1).sum::<usize>();
                break;
            } else if current_workflow == "R" {
                println!("REJECT");
                break;
            }
        }
    }

    println!("{sum}");
}
